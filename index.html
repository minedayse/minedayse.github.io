<!DOCTYPE html>
<html>

<head>

<title> PDI com Dayse e Yasmin </title>

</head>

<body style="height:100%; width:80%" bgcolor="#0F000F">

<font size = +2 face = "Arial" color="white" >

<H1> <center> Exercicios de Processamento Digital de Imagens com OpenCV </center> </H1>

Alunas: Dayse e Yasmin. <P>
Professor: Agostinho Brito. <P>


<H2><center> Introducao </center></H2>

Essa pagina tem como objetivo explorar assuntos estudados em sala de aula atraves de exercicios propostos pelo professor. Ela foi construida por duas alunas da Universidade Federal do Rio Grande do Norte que estao cursando a disciplina de Processamento Digital de Imagens. <P>

<H2><center> Material </center></H2>

Para a realizacao dos exercicios propostos, utilizamos a ferramenta OpenCV e o sistema operacional Ubuntu. Pelo prompt de comando, o OpenCV foi instalado e configurado. O material que foi utilizado como base teorica para a realizacao desses exercicios encontra-se na pagina do professor, <A HREF="http://agostinhobritojr.github.io/"> Agostinho Brito </A> .

<H2> <center> Exercicio 1 - Manipulacao de Pixels </center> </H2>

Este exercicio tem o proposito de ajudar no entendimento sobre manipulacao de imagens, apos um estudo teorico sobre componentes de uma imagem e maneiras de manipula-la. 
Para receber a imagem, fazer alteracoes nela, criar uma nova e exibi-la, sera utilizado o conjunto de bibliotecas OpenCV. <P>
O exercicio consiste em, dado dois valores P1 e P2, transformar uma imagem de forma que a regiao presente entre P1 e P2 conterao o negativo da mesma e o resto se mantera. Para isso, P1 e P2 devem ser valores presentes no conjunto de pixels da imagem e o resultado da transformacao se dara numa regiao com formato retangular. <P>

<H3> <center> Teoria </center> </H3>

A ideia para a execucao desse exercicio consistiu em seu principio de fazer o upload de uma imagem em grayscale (tons de cinza) e ler os valores P1 e P2. Em seguida, deve-se criar uma regiao variando do ponto x do pixel P1 ao ponto x do pixel P2 e do ponto y de P1 ao ponto y de P2. Dentro dessa regiao, uma transformacao sera feita, <P>
Para finalizar, deve-se gerar uma imagem nova e exibi-la. <P>

<H3> <center> Funcoes </center> </H3>

As funcoes fundamentais para a execucao dessa atividade e o que elas representam sao: <P>

<UL>
<LI> Mat: cria uma matriz que armazenara os dados dos pixels das imagens.
<LI> imread: le uma imagem e armazena numa matriz.
<LI> namedWindow: cria uma janela.
<LI> imagem.at<uchar>(x, y): representa o valor do pixel de posicao x e y da matriz imagem.
<LI> imshow(,): mostra na janela uma imagem.
<LI> imwrite(,): cria um arquivo com uma matriz de imagem contida no programa.
</UL>

<H3> <center> Imagem </center> </H3>

Para a realizacao do exercicio, foi utilizada a seguinte imagem como base: <P>

<center>
<IMG SRC = "imagem.png" width=35% height = 35% alt="Exemplo 1"> 

<H3> Codigo comentado </H3>
</center>
<font size = +1 face = "helvetica"> 

<I>
#include <iostream>
<BR>#include <cv.h>
<BR>#include <highgui.h>
<P>
using namespace cv;
<BR>using namespace std;
<P>
int main(int, char**){
<BR>  Mat image;
<P>
  image= imread("imagem.png",CV_LOAD_IMAGE_GRAYSCALE);
<P>
  if(!image.data){
<BR>    cout << "Erro: Nao foi possivel carregar a imagem." << endl;
<BR>  }
<P>
  else{
<BR>    namedWindow("Janela",WINDOW_AUTOSIZE);
<P>
    int x1, x2, y1, y2;
<P>
    cout << "Ponto 1" << endl;
<BR>    cout << "X: ";
<BR>    cin >> x1;
<BR>    cout << "Y: ";
<BR>    cin >> y1;
<BR>    cout << "Ponto 2" << endl;
<BR>    cout << "X: ";
<BR>    cin >> x2;
<BR>    cout << "Y: ";
<BR>    cin >> y2; 
<P>
// Negativar regiao entre os pontos 1 e 2
<BR>    for(int i=x1;i<x2;i++){
<BR>      for(int j=y1;j<y2;j++){
<BR>        image.at<uchar>(i,j)=255 - image.at<uchar>(i,j);
<BR>      }
<BR>    }
<P>  
    imshow("Janela", image);  
<BR>    imwrite("imagemnegativa.png", image);
<BR>    waitKey();
<BR>    }
<P>
  return 0;
<BR>}

</I>
</font>

<H3> <center> Resultados </center> </H3>

Apos a execucao do codigo atraves dos comandos "make negativo" e "./negativo" no prompt de comando, o programa pede os valores de P1 e P2, sendo primeiro o "x" e depois o "y" de cada ponto. Como exemplo, utilizou-se P1= (100, 100) e P2= (400, 400). O resultado do programa pode ser visto a seguir:
<P>
<center>
<IMG SRC = "imagemnegativa.png" width=35% height = 35% alt="Exercicio 1"> 
<P>

<H2> Exercicio 2 - Troca de Regioes </H2>
</center>

Com este exercicio, ve-se o resultado do aprendizado base com relacao a manipulacao de imagens. Para ele, sera necessario conceitos basicos de separacao de regioes e programacao. Para a execucao dessa proposta, ainda sera utilizado o conjunto de bibliotecas OpenCV, de forma a receber a imagem, fazer alteracoes nela, criar uma nova e exibi-la. O sistema operacional presente durante esse processo foi o Ubuntu. <P>
O exercicio consiste em, dado uma imagem, dividi-la em quatro regioes e trocar as posicoes delas. A regiao superior esquerda deve trocar de lugar com a inferior direita e a regiao superior direita deve ser trocada com a inferior esquerda. <P>

<H3> <center> Teoria </center> </H3>

A ideia para o funcionamento desse exercicio comecou com o upload de uma imagem escolhida previamente. Em seguida, para nao gastar mais linhas, deve-se definir logo a imagem nova e definir o valor de seus pixels de acordo com as regioes da imagem original.
A separaracao das regioes escolhidas se dara variando do ponto inicial a metade do comprimento da imagem e a metade de sua altura para a regiao superior esquerda. <P>
A regiao superior esqueda (1) sera definida dos valores iniciais de x e y ate a metade da altura e a metade da largura da imagem, respectivamente. A regiao superior direita (2) sera definida do ponto inicial ate a metade da altura para os valores de x e da metade do comprimento ate o final dele para os valores de y. A regiao inferior esquerda (3) sera definida da metade da altura ate o final dela para os valores de x e do ponto inicial ate a metade do comprimento para os valores de y. Seguindo a mesma logica, a ultima regiao (4) sera composta pelo que sobrou. <P>
Nota-se que apenas 3 resultados podem ser obtidos, tendo em vista que a regiao 1 pode trocar de lugar com qualquer uma das 3 outras, contudo as duas que restarem devem trocar de lugar entre si. Entao, a troca pode ocorrer de tres formas: entre as regioes 1-2 e 3-4 (troca na horizontal), entre as regioes 1-3 e 2-4 (troca na vertical) ou entre as regioes 1-4 e 2-3. A logica dela consiste em armazenar os dados da primeira regiao numa variavel, depois modificar essa regiao com os dados da desejada e em seguida modificar os dados da desejada utilizando o que foi armazenado na variavel. Para finalizar, deve-se exibir na tela a nova imagem. <P>

<H3> <center> Funcoes </center> </H3>

As funcoes adicionais essenciais para a execucao dessa atividade e o que elas representam sao: <P>

<UL>
<LI> rand: gera um numero aleatorio.
<LI> imagem.size().width: retorna o valor da largura da imagem.
<LI> imagem.size().height: retorna o valor da altura da imagem.
</UL>

<H3> <center> Imagem </center> </H3>

Para a realizacao do exercicio, foi utilizada a mesma imagem do exercicio anterior como base. Ela esta mostrada a seguir: <P>
<center>
<IMG SRC = "imagem.png" width=35% height = 35% alt="Exemplo3">

<H3> Codigo comentado </H3>
</center>
<font size = +1 face = "helvetica"> 

<I>

#include <iostream>
<BR>#include <cv.h>
<BR>#include <highgui.h>
<P>
using namespace cv;
<BR>using namespace std;
<P>
int main(int, char**){
<P>
srand(time(NULL));
<P>
  Mat image;
<BR>  int width, height;
<BR>  int t;// Troca (regioes)
<BR>  int aux1, aux2; // Auxiliar
<P>
  image= imread("imagem.png",CV_LOAD_IMAGE_GRAYSCALE);
<P>
  if(!image.data){
<BR>    cout << "Erro: Nao foi possivel carregar a imagem." << endl;
<BR>  }
<P>
  else{
<BR>  namedWindow("Janela",WINDOW_AUTOSIZE);
<P>
  width=image.size().width;
<BR>  height=image.size().height;
<P> 
// Translacao
<BR>  t = rand() % 3; // Troca aleatoria
<BR>  if(t==0){ // 1-2, 3-4
<BR>    for(int i=0;i<height/2;i++){
<BR>      for(int j=0;j<width/2;j++){
<BR>        aux1 = image.at<uchar>(i,j);
<BR>        image.at<uchar>(i,j) = image.at<uchar>(i,j + width/2);
<BR>        image.at<uchar>(i,j + width/2) = aux1;
<BR>        aux2 = image.at<uchar>(i + height/2,j);
<BR>        image.at<uchar>(i + height/2,j) = image.at<uchar>(i + height/2,j + width/2);
<BR>        image.at<uchar>(i + height/2,j + width/2) = aux2;
<BR>      }
<BR>    }
<BR>  }
<BR>  else if(t==1){ // 1-3, 2-4
<BR>    for(int i=0;i<height/2;i++){
<BR>      for(int j=0;j<width/2;j++){
<BR>        aux1 = image.at<uchar>(i,j);
<BR>        image.at<uchar>(i,j) = image.at<uchar>(i + height/2,j);
<BR>        image.at<uchar>(i + height/2,j) = aux1;
<BR>        aux2 = image.at<uchar>(i,j + width/2);
<BR>        image.at<uchar>(i,j + width/2) = image.at<uchar>(i + height/2,j + width/2);
<BR>        image.at<uchar>(i + height/2,j + width/2) = aux2;
<BR>      }
<BR>     }
<BR>  } 
<BR>  else{ // 1-4, 2-3
<BR>    for(int i=0;i<height/2;i++){
<BR>      for(int j=0;j<width/2;j++){
<BR>        aux1 = image.at<uchar>(i,j);
<BR>        image.at<uchar>(i,j) = image.at<uchar>(i + height/2,j + width/2);
<BR>        image.at<uchar>(i + height/2,j + width/2) = aux1;
<BR>        aux2 = image.at<uchar>(i,j + width/2);
<BR>        image.at<uchar>(i,j + width/2) = image.at<uchar>(i + height/2,j);
<BR>        image.at<uchar>(i + height/2,j) = aux2;
<BR>      }
<BR>     }
<BR>  }
<BR>// FimTranslacao
<P>  
  imshow("Janela", image);  
<BR>  imwrite("Exemplo2.png", image);
<BR>  waitKey();
<BR>  }
<P>
  return 0;
<BR>}

</I>
</font>

<H3> <center> Resultados </center> </H3>

Para obter resultados, o codigo correspondente, com o nome "trocaderegioes.cpp", foi executado pelo prompt de comando. Esse exercicio foi executado diversas vezes, pois a troca de regioes esta aleatoria e assim foi possivel verificar todas as possibilidades, que estao mostradas a seguir: <P>
<center>
<BR>Troca 1-2, 3-4<P>
<IMG SRC = "Exemplo21.png" width=35% height = 35% alt="Exercicio 21"> 
<BR>Troca 1-3, 2-4<P>
<IMG SRC = "Exemplo22.png" width=35% height = 35% alt="Exercicio 22"> 
<BR>Troca 1-4, 2-3<P>
<IMG SRC = "Exemplo23.png" width=35% height = 35% alt="Exercicio 23"> 

<P>
<H2>Exercicio 3 - Teoria sobre preenchimento de regioes</H2>
</center>

<H3><center> Identificacao do problema </center></H3>

Tendo-se como exemplo o codigo a seguir, que rotula uma imagem binaria utilizando o algoritmo <i>seedfill</i> para descobrir aglomerados de pixels, ao analisa-lo, consegue-se verificar alguns possiveis problemas.<P>
O principal dele e que o algoritmo de rolulacao nao consegue identificar mais de 255 objetos na imagem, porque ele trabalha com <i>grayscale</i>, que tem uma escala de tons de cinza que varia de 0 ate 255 e o algoritmo da diferentes rotulos.
Logo, se ha mais de 255 objetos na imagem, nao existirao cores diferentes para completar a contagem.<P>


<H3><center> Codigo comentado </center> </H3>
</center>
<I>
#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<P>
using namespace cv;
<P>
int main(int argc, char** argv){
<BR>  Mat image, mask;
<BR>  int width, height;
<BR>  int nobjects;
<P>  
  CvPoint p;
<BR>  image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);
<P>  
  if(!image.data){
<BR>    std::cout << "imagem nao carregou corretamente\n";
<BR>    return(-1);
<BR>  }
<BR>  width=image.size().width;
<BR>  height=image.size().height;
<P>
  p.x=0;
<BR>  p.y=0;
<P>
  // busca objetos com buracos presentes
<BR>  nobjects=0;
<BR>  for(int i=0; i<height; i++){
<BR>    for(int j=0; j<width; j++){
<BR>      if(image.at<uchar>(i,j) == 255){
<BR>		// achou um objeto
<BR>		nobjects++;
<BR>		p.x=j;
<BR>		p.y=i;
<BR>		floodFill(image,p,nobjects);
<BR>	  }
<BR>	}
<BR>  }
<BR>  imshow("image", image);
<BR>  imwrite("labeling.png", image);
<BR>  waitKey();
<BR>  return 0;
<BR>}
</I>

<H3> <center> Resolucao </center></H3> 

Uma solucao simples para o problema em questao desse codigo, seria criar uma nova variavel para realizar a mesma contagem que o <i>nobjects</i> e que possa ser resetada se o valor maximo for atingido. Isso tudo sem comprometer a rotulacao dos objetos desejados.

<center>

<H2>Exercicio 4 - Identificando furos </H2>
</center>

Esse exercicio propoe a modificacao de um algoritmo de rotulacao para separar regioes desejadas e dentro delas selecionar um subconjunto. Dessa forma, deve-se praticar a logica e conceitos previos de rotulacao e de manipulacao de pixels. <P>
A ideia e, dada uma imagem de cor binaria, com fundo preto e "bolhas" brancas espalhadas por ela, deve-se selecionar e contar as bolhas, separando-as entre as que possuem furo (em preto) e as que nao. <P>

<H3><center> Teoria </center></H3>

O codigo para a execucao desse exercicio consiste em tres passos principais. Inicialmente, deve-se retirar os elementos que tocam as bordas, ja que podem haver buracos nessas bolhas que nao sao visiveis na imagem disponivel. Para tanto, igualam-se todos os pixel da borda a 255 e depois pintam-se esses mesmos pixels e os que os tocam de 0.<P>
Em seguida, faz-se a rotulacao dos objetos atraves do algoritmo <i>seedfill</i> ja visto. E, por fim, percorre-se cada objeto em busca de um pixel (ou mais) com a cor do fundo, realizando assim a contagem de elementos com e sem buracos.<P>
Esse codigo contou com dois extras explicitados nos comentarios, onde os buracos podem ou nao ficar visiveis na imagem final e pode-se destinguir as bolhas com apenas dois tons de cinza (um para com buracos e outro para sem) ou com a mesma variacao de 0 a 255 do exercicio anterior.<P>
Adicionalmente, o codigo gera uma nova imagem, com nome "labeling". <P>

<H3><center> Funcoes </center></H3>

As funcoes adicionais essenciais para a execucao dessa atividade e o que elas representam sao: <P>

<UL>
<LI> CvPoint: gera um ponto bidimensional.
<LI> floodFill: executa o algoritmo <i>seedfill</i> na imagem com base em um pixel como semente.
</UL>

<H3><center>Imagem</center></H3>

A imagem utilizada como base para esse exercicio esta mostrada a seguir:<P>

<center>
<IMG SRC = "imagem2.png" width=50% height=50% alt="Exemplo 4">

<H3> Codigo comentado </H3>
</center>
<I>
#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<P>
using namespace cv;
<P>
int main(int argc, char** argv){
<BR>  Mat image, mask;
<BR>  int width, height;
<BR>  int nobjects, cont;
<P>  
  CvPoint p;
<BR>  image = imread("imagem2.png",CV_LOAD_IMAGE_GRAYSCALE);
<P>  
  if(!image.data){
<BR>    std::cout << "Erro: Nao foi possivel carregar a imagem.\n";
<BR>    return(-1);
<BR>  }
<BR>  width=image.size().width;
<BR>  height=image.size().height;
<P>
  p.x=0;
<BR>  p.y=0;
<P>
  nobjects=0;
<BR>  cont = 0;
<BR>  for(int i=0; i<height; i++){
<BR>    for(int j=0; j<width; j++){
<BR>      if(image.at<uchar>(i,j) == 255){ // Encontrou um objeto
<BR>		nobjects++;
<BR>		cont++;
<BR>		p.x=j;
<BR>		p.y=i;
<BR>		floodFill(image,p,cont);
<BR>		if(cont==254){ cont = 0;} // Estourou o limite do contador, zerar
<BR>	  }
<BR>	}
<BR>  } 
<BR>  std::cout << "Numero de objetos: " << nobjects << "\n"; // Total de objetos encontrados
<P>
  imshow("image", image);
<BR>  imwrite("labeling.png", image);
<BR>  waitKey();
<BR>  return 0;
<BR>}
</I>
<H3><center> Resultados</center> </H3>

Como resultado, pode-se ver que o codigo conseguiu diferenciar as bolhas e tambem fazer a variacao de tons, se desejado.<P>

<center>

Sem bolhas<P>
<IMG SRC = "Exercicio41.png" width=50% height=50% alt="Exercicio 41">
<BR>Com bolhas<P>
<IMG SRC = "Exercicio42.png" width=50% height=50% alt="Exercicio 42">
<BR>Com variacao de tons<P>
<IMG SRC = "Exercicio43.png" width=50% height=50% alt="Exercicio 43">


<H2>Exercicio 5 - Equalizacao de Histograma</H2>
</center>

Esse exercicio tem como objetivo explorar o conhecimento sobre histogramas de uma imagem e a manipulacao dele atraves do conjunto de bibliotecas OpenCV, alem de utilizar captura de video. Para isso, a ideia e que, para cada imagem gerada, o programa .cpp equalize o histograma da imagem e mostre na tela.<P>

<H3><center> Teoria </center></H3>

Para o funcionamento desse, codigo, e necessario tres passos: capturar <i>frames</i> de video, realizar a equalizacao do histograma para cada imagem dessas e exibir as images apos a modificacao.<P>
E importante saber que, para a manipulacao do histograma, foi necessario inicialmente muda-se o sistema de cores de RGB para YCrCb. Em seguida, o histograma pode ser calculado e normalizado.<P>

<H3><center> Funcoes </center></H3>

<UL>
<LI> VideoCapture: classe que permite uma variavel fluxo de video, possui como principais funcoes <i>open</i> (abre video da camera) e <i>get</i> (receber informacoes da captura).
<LI> planes[]: separa a imagem em tons (planos) de vermelho, verde e azul.
<LI> cvtColor: consegue alterar o sistema de cores.
<LI> equalizeHist: equaliza diretamente um histograma.
<LI> merge: junta os planos de cor em uma imagem so.
<LI> calcHist: recebe referencia a ser processada, calcula o histograma e retorna para uma variavel definida.
<LI> normalize: normaliza os valores do histograma para o ficarem proporcionais ao maximo e minimo encontrado.
<LI> line: gera grafico de barras.
</UL>

<H3><center>Imagem</center></H3>

Uma imagem para servir de previa foi mostrada, utilizando um algoritmo que exibe a imagem captada pela camera e gera o histograma.<P>

<center>

<IMG SRC = "Exemplo5.png" width=50% height=50% alt="Exemplo 5">

<H3> Codigo comentado </H3>
</center>
<I>
#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<P>
using namespace cv;
<BR>using namespace std;
<P>
int main(int argc, char** argv){
<BR>  Mat rawimage, eqimage;
<BR>  int width, height;
<BR>  VideoCapture cap;
<BR>  vector<Mat> planes;
<BR>  Mat histR, histG, histB;
<BR>  int nbins = 64;
<BR>  float range[] = {0, 256};
<BR>  const float *histrange = { range };
<BR>  bool uniform = true;
<BR>  bool acummulate = false;
<P>
  cap.open(0);
<P>  
  if(!cap.isOpened()){
<BR>    cout << "Erro: Cameras indisponiveis.";
<BR>    return -1;
<BR>  }
<P>  
  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
<BR>  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);
<P>
  cout << "Largura = " << width << endl;
<BR>  cout << "Altura  = " << height << endl;
<P>	
  int histw = nbins, histh = nbins/2;
<BR>  Mat histImgR(histh, histw, CV_8UC3, Scalar(0,0,0));
<BR>  Mat histImgG(histh, histw, CV_8UC3, Scalar(0,0,0));
<BR>  Mat histImgB(histh, histw, CV_8UC3, Scalar(0,0,0));
<P>
  while(1){
<BR>    cap >> rawimage;
<BR>    cvtColor(rawimage, eqimage, CV_BGR2YCrCb); // Muda a cor de RGB para YCrCb
<BR>    for (int i=0; i<1; i++) {
<BR>	    split (eqimage, planes);
<BR>	    equalizeHist(planes[i], planes[i]);
<BR>	    merge(planes, eqimage);
<BR>    }
<BR>    cvtColor(eqimage, eqimage, CV_YCrCb2BGR); 
<BR>    calcHist(&planes[0], 1, 0, Mat(), histR, 1,
<BR>             &nbins, &histrange,
<BR>             uniform, acummulate);
<BR>    calcHist(&planes[1], 1, 0, Mat(), histG, 1,
<BR>             &nbins, &histrange,
<BR>             uniform, acummulate);
<BR>    calcHist(&planes[2], 1, 0, Mat(), histB, 1,
<BR>             &nbins, &histrange,
<BR>             uniform, acummulate);
<P>

    normalize(histR, histR, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
<BR>    normalize(histG, histB, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
<BR>    normalize(histB, histB, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
<P>
    histImgR.setTo(Scalar(0));
<BR>    histImgG.setTo(Scalar(0));
<BR>    histImgB.setTo(Scalar(0));
<P>    
    for(int i=0; i<nbins; i++){
<BR>      line(histImgR, Point(i, histh),
<BR>           Point(i, cvRound(histR.at<float>(i))),
<BR>           Scalar(0, 0, 255), 1, 8, 0);
<BR>      line(histImgG, Point(i, histh),
<BR>           Point(i, cvRound(histG.at<float>(i))),
<BR>           Scalar(0, 255, 0), 1, 8, 0);
<BR>      line(histImgB, Point(i, histh),
<BR>           Point(i, cvRound(histB.at<float>(i))),
<BR>           Scalar(255, 0, 0), 1, 8, 0);
<BR>    }
<BR>    histImgR.copyTo(eqimage(Rect(0, 0       ,nbins, histh)));
<BR>    histImgG.copyTo(eqimage(Rect(0, histh   ,nbins, histh)));
<BR>    histImgB.copyTo(eqimage(Rect(0, 2*histh ,nbins, histh)));
<BR>    imshow("image", eqimage);
<BR>    if(waitKey(30) >= 0) break;
<BR>  }
<BR>  return 0;
<BR>}
</I>

<H3><center> Resultados</center> </H3>

Como proposto, pode-se ver nao so a diferenca na imagem, como o que mudou nos histogramas.<P>

<center>
<IMG SRC = "Exercicio5.png" width=50% height=50% alt="Exercicio 5">

<H2>Exercicio 6 - </H2>
</center>

Esse exercicio envolve a utilizacao de filtros e video. Para isso, sera criado um programa .cpp que recebera <i>frames</i> de video e, dependendo do que o usuario selecionar, aplicara um filtro espacial atraves do uso de mascaras. Nesse caso, estaremos tambem testando o filtro laplaciano do gaussiano. <P>

<H3><center> Teoria </center></H3>

Para a execucao dessa proposta, os passos serao: a captura de imagens em fluxo, escolha do filtro, aplicacao da mascara e criacao de um novo fluxo de imagens. O programa feito cria mascaras 3x3 para os seguintes filtros: do modulo, da media, gaussiano, vertical, horizontal e laplaciano. Os filtros sao ativados pelas teclas "a", "m", "g", "v", "h" e "l", respectivamente. Para ativar o laplaciano do gaussiano, foi necessario uma mascara 5x5 e o usuario deve teclar "x". <P>


<H3><center> Funcoes </center></H3>

As principais funcoes para a realizacao desse exercicio seguem:

<UL>
<LI> mask: recebe uma matriz em ponto flutuante com valores da mascara correspondente ao filtro desejado.
<LI> cvtColor: esta sendo usado para alterar o sistema de cores para tons de cinza.
<LI> frame.convertTo: converte as imagens capturadas pela camera para pontos flutuantes.
<LI> filter2D: realiza a convolucao da mascara com a imagem capturada.

</UL>

<center>
<H3> Codigo comentado </H3>
</center>
<I>

#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<BR>using namespace cv;
<BR>using namespace std;
<P>
void printmask(Mat &m){
<BR>  for(int i=0; i<m.size().height; i++){
<BR>    for(int j=0; j<m.size().width; j++){
<BR>      cout << m.at<float>(i,j) << ",";
<BR>    }
<BR>    cout << endl;
<BR>  }
<BR>}
<P>
void menu(){
<BR>  cout << "\nPressione a tecla para ativar o filtro: \n"
<BR>	  "a - Calcular o modulo\n"
<BR>          "m - Media\n"
<BR>          "g - Gauss\n"
<BR>          "v - Vertical\n"
<BR>	  "h - Horizontal\n"
<BR>          "l - Laplaciano\n"
<BR>          "x - Laplaciano do gaussiano\n"
<BR>	  "esc - Sair\n";
<BR>}
<P>
int main(int argvc, char** argv){
<BR>  VideoCapture video;
<BR>  float media[] = {1,1,1,
<BR>				   1,1,1,
<BR>				   1,1,1};
<BR>  float gauss[] = {1,2,1,
<BR>				   2,4,2,
<BR>				   1,2,1};
<BR>  float horizontal[]={-1,0,1,
<BR>					  -2,0,2,
<BR>					  -1,0,1};
<BR>  float vertical[]={-1,-2,-1,
<BR>					0,0,0,
<BR>					1,2,1};
<BR>  float laplacian[]={0,-1,0,
<BR>					 -1,4,-1,
<BR>					 0,-1,0};
<BR>  float lap_gauss[]={0,0,1,0,0,
<BR>		     0,1,2,1,0,
<BR>		     1,2,-16,2,1,
<BR>		     0,1,2,1,0,
<BR>		     0,0,1,0,0};
<P>
  Mat cap, frame, frame32f, frameFiltered;
<BR>  Mat mask(3,3,CV_32F), mask1;
<BR>  Mat result, result1;
<BR>  double width, height, min, max;
<BR>  int absolut;
<BR>  char key;
<P>  
  video.open(0); 
<BR>  if(!video.isOpened()) 
<BR>    return -1;
<BR>  width=video.get(CV_CAP_PROP_FRAME_WIDTH);
<BR>  height=video.get(CV_CAP_PROP_FRAME_HEIGHT);
<BR>  std::cout << "Largura =" << width << "\n";;
<BR>  std::cout << "Altura =" << height<< "\n";;
<P>
  namedWindow("filtroespacial",1);
<P>
  mask = Mat(3, 3, CV_32F, media); 
<BR>  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
<BR>  swap(mask, mask1);
<BR>  absolut=1; // calcs abs of the image
<P>
  menu();
<BR>  for(;;){
<BR>    video >> cap; 
<BR>    cvtColor(cap, frame, CV_BGR2GRAY);
<BR>    flip(frame, frame, 1);
<BR>    imshow("original", frame);
<BR>    frame.convertTo(frame32f, CV_32F);
<BR>    filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);
<BR>    if(absolut){
<BR>      frameFiltered=abs(frameFiltered);
<BR>    }
<BR>    frameFiltered.convertTo(result, CV_8U);
<BR>    imshow("filtroespacial", result);
<BR>    key = (char) waitKey(10);
<BR>    if( key == 27 ) break; // esc pressed!
<BR>    switch(key){
<BR>    case 'a':
<BR>	  menu();
<BR>      absolut=!absolut;
<BR>      break;
<BR>    case 'm':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, media);
<BR>      scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
<BR>      mask = mask1;
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'g':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, gauss);
<BR>      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
<BR>      mask = mask1;
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'h':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, horizontal);
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'v':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, vertical);
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'l':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, laplacian);
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'x':
<BR>	  menu();
<BR>      mask = Mat(5, 5, CV_32F, lap_gauss);
<BR>      printmask(mask);
<BR>      break;
<BR>    default:
<BR>      break;
<BR>    }
<BR>  }
<BR>  return 0;
<BR>}
</I>
<H3><center> Resultados</center> </H3>

No fim, o programa mostra a imagem original e o filtro desejado. Para poder compara o uso dos filtros, a seguir vem um exemplo do laplaciano do gaussiano e um com apenas o laplaciano: <P>

<center>
Laplaciano do gaussiano:<P>
<IMG SRC = "Exercicio6.png" width=50% height=50% alt="Exercicio 61">
<BR>Laplaciano:<P>
<IMG SRC = "Exercicio61.png" width=50% height=50% alt="Exercicio 62">

</font>
</body>

</html>
