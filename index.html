<!DOCTYPE html>
<html>

<head>

<title> PDI com Dayse e Yasmin </title>

</head>

<body style="height:100%; width:80%" bgcolor="#0F000F">

<font size = +2 face = "Arial" color="white" >

<H1> <center> Exerc&iacutecios de Processamento Digital de Imagens com OpenCV </center> </H1>

Alunas: Dayse Maranh&atildeo Cavalcanti<BR>
Yasmin Honorio de Medeiros. <P>
Professor: Agostinho Brito. <P>


<H2><center> Introdu&ccedil&atildeo </center></H2>

Essa pagina tem como objetivo explorar assuntos estudados em sala de aula atrav&eacutes de exerc&iacutecios propostos pelo professor. Ela foi constru&iacuteda por duas alunas da Universidade Federal do Rio Grande do Norte que estao cursando a disciplina de Processamento Digital de Imagens. <P>

<H2><center> Material </center></H2>

Para a realiza&ccedil&atildeo dos exerc&iacutecios propostos, utilizou-se a ferramenta OpenCV e o sistema operacional Ubuntu. Pelo prompt de comando, o OpenCV foi instalado e configurado. O material que foi utilizado como base teorica para a realiza&ccedil&atildeo desses exerc&iacutecios encontra-se na pagina do professor, <A HREF="http://agostinhobritojr.github.io/"> Agostinho Brito </A> .

<H2> <center> Exerc&iacutecio 1 - Manipula&ccedil&atildeo de Pixels </center> </H2>

Este exerc&iacutecio tem o proposito de ajudar no entendimento sobre manipulacao de imagens, apos um estudo teorico sobre componentes de uma imagem e maneiras de manipula-la. 
Para receber a imagem, fazer altera&ccedil&otildees nela, criar uma nova e exib&iacute-la, sera utilizado o conjunto de bibliotecas OpenCV. <P>
O exerc&iacutecio consiste em, dado dois valores P1 e P2, transformar uma imagem de forma que a regi&atildeo presente entre P1 e P2 contera o negativo da mesma e o resto se mantera. Para isso, P1 e P2 devem ser valores presentes no conjunto de pixels da imagem e o resultado da transforma&ccedil&atildeo se dara numa regi&atildeo com formato retangular. <P>

<H3> <center> Teoria </center> </H3>

A ideia para a execu&ccedil&atildeo desse exerc&iacutecio consistiu em seu princ&iacutepio de fazer o upload de uma imagem em grayscale (tons de cinza) e ler os valores P1 e P2. Em seguida, deve-se criar uma regi&atildeo variando do ponto x do pixel P1 ao ponto x do pixel P2 e do ponto y de P1 ao ponto y de P2. Dentro dessa regiao, uma transforma&ccedil&atildeo sera feita, <P>
Para finalizar, deve-se gerar uma imagem nova e exibi-la. <P>

<H3> <center> Fun&ccedil&otildees </center> </H3>

As fun&ccedil&otildees fundamentais para a execu&ccedil&atildeo dessa atividade e o que elas representam s&atildeo: <P>

<UL>
<LI> Mat: cria uma matriz que armazenara os dados dos pixels das imagens.
<LI> imread: le uma imagem e armazena numa matriz.
<LI> namedWindow: cria uma janela.
<LI> imagem.at<uchar>(x, y): representa o valor do pixel de posi&ccedil&atildeo x e y da matriz imagem.
<LI> imshow(,): mostra na janela uma imagem.
<LI> imwrite(,): cria um arquivo com uma matriz de imagem contida no programa.
</UL>

<H3> <center> Imagem </center> </H3>

Para a realiza&ccedil&atildeo do exerc&iacutecio, foi utilizada a seguinte imagem como base: <P>

<center>
<IMG SRC = "imagem.png" width=35% height = 35% alt="Exemplo 1"> 

<H3> Codigo comentado </H3>
</center>
<font size = +1 face = "helvetica"> 

<I>
#include <iostream>
<BR>#include <cv.h>
<BR>#include <highgui.h>
<P>
using namespace cv;
<BR>using namespace std;
<P>
int main(int, char**){
<BR>  Mat image;
<P>
  image= imread("imagem.png",CV_LOAD_IMAGE_GRAYSCALE);
<P>
  if(!image.data){
<BR>    cout << "Erro: Nao foi possivel carregar a imagem." << endl;
<BR>  }
<P>
  else{
<BR>    namedWindow("Janela",WINDOW_AUTOSIZE);
<P>
    int x1, x2, y1, y2;
<P>
    cout << "Ponto 1" << endl;
<BR>    cout << "X: ";
<BR>    cin >> x1;
<BR>    cout << "Y: ";
<BR>    cin >> y1;
<BR>    cout << "Ponto 2" << endl;
<BR>    cout << "X: ";
<BR>    cin >> x2;
<BR>    cout << "Y: ";
<BR>    cin >> y2; 
<P>
// Negativar regiao entre os pontos 1 e 2
<BR>    for(int i=x1;i<x2;i++){
<BR>      for(int j=y1;j<y2;j++){
<BR>        image.at<uchar>(i,j)=255 - image.at<uchar>(i,j);
<BR>      }
<BR>    }
<P>  
    imshow("Janela", image);  
<BR>    imwrite("imagemnegativa.png", image);
<BR>    waitKey();
<BR>    }
<P>
  return 0;
<BR>}

</I>
</font>

<H3> <center> Resultados </center> </H3>

Apos a execu&ccedil&atildeo do codigo atrav&eacutes dos comandos "make negativo" e "./negativo" no prompt de comando, o programa pede os valores de P1 e P2, sendo primeiro o "x" e depois o "y" de cada ponto. Como exemplo, utilizou-se P1= (100, 100) e P2= (400, 400). O resultado do programa pode ser visto a seguir:
<P>
<center>
<IMG SRC = "imagemnegativa.png" width=35% height = 35% alt="Exercicio 1"> 
<P>

<H2> Exerc&iacutecio 2 - Troca de Regioes </H2>
</center>

Com este exerc&iacutecio, ve-se o resultado do aprendizado base com relacao a manipula&ccedil&atildeo de imagens. Para a realiza&ccedil&atildeo dele, sera necessario conceitos basicos de separacao de regi&otildees e programa&ccedil&atildeo. Para a execu&ccedil&atildeo dessa proposta, ainda sera utilizado o conjunto de bibliotecas OpenCV, de forma a receber a imagem, fazer alteracoes nela, criar uma nova e exib&iacute-la. <P>
O exerc&iacutecio consiste em, dado uma imagem, divid&iacute-la em quatro regioes e trocar as posi&ccedil&otildees delas. Por exemplo, a regi&atildeo superior esquerda deve trocar de lugar com a inferior direita e a regi&atildeo superior direita deve ser trocada com a inferior esquerda. <P>

<H3> <center> Teoria </center> </H3>

A ideia para o funcionamento desse exerc&iacutecio comecou com o upload de uma imagem escolhida previamente. Em seguida, para n&atildeo gastar mais linhas, deve-se definir logo a imagem nova e definir o valor de seus pixels de acordo com as regi&otildees da imagem original.
A separara&ccedil&atildeo das regi&otildees escolhidas se dara variando do ponto inicial a metade do comprimento da imagem e a metade de sua altura para a regi&atildeo superior esquerda. <P>
A regi&atildeo superior esqueda (1) sera definida dos valores iniciais de x e y at&eacute a metade da altura e a metade da largura da imagem, respectivamente. A regi&atildeo superior direita (2) sera definida do ponto inicial at&eacute a metade da altura para os valores de x e da metade do comprimento at&eacute o final dele para os valores de y. A regi&atildeo inferior esquerda (3) sera definida da metade da altura at&eacute o final dela para os valores de x e do ponto inicial ate a metade do comprimento para os valores de y. Seguindo a mesma logica, a ultima regi&atildeo (4) sera composta pelo que sobrou. <P>
Nota-se que apenas 3 resultados podem ser obtidos, tendo em vista que a regi&atildeo 1 pode trocar de lugar com qualquer uma das 3 outras, contudo as duas que restarem devem trocar de lugar entre si. Ent&atildeo, a troca pode ocorrer de tres formas: entre as regioes 1-2 e 3-4 (troca na horizontal), entre as regioes 1-3 e 2-4 (troca na vertical) ou entre as regioes 1-4 e 2-3. A logica dela consiste em armazenar os dados da primeira regi&atildeo numa variavel, depois modificar essa regi&atildeo com os dados da desejada e em seguida modificar os dados da desejada utilizando o que foi armazenado na variavel. Para finalizar, deve-se exibir na tela a nova imagem. <P>

<H3> <center> Fun&ccedil&otildees </center> </H3>

As fun&ccedil&otildees adicionais essenciais para a execu&ccedil&atildeo dessa atividade e o que elas representam s&atildeo: <P>

<UL>
<LI> rand: gera um numero aleatorio.
<LI> imagem.size().width: retorna o valor da largura da imagem.
<LI> imagem.size().height: retorna o valor da altura da imagem.
</UL>

<H3> <center> Imagem </center> </H3>

Para a realiza&ccedil&atildeo desse exerc&iacutecio, foi utilizada a mesma imagem do exerc&iacutecio anterior como base. Ela esta mostrada a seguir: <P>
<center>
<IMG SRC = "imagem.png" width=35% height = 35% alt="Exemplo3">

<H3> Codigo comentado </H3>
</center>
<font size = +1 face = "helvetica"> 

<I>

#include <iostream>
<BR>#include <cv.h>
<BR>#include <highgui.h>
<P>
using namespace cv;
<BR>using namespace std;
<P>
int main(int, char**){
<P>
srand(time(NULL));
<P>
  Mat image;
<BR>  int width, height;
<BR>  int t;// Troca (regioes)
<BR>  int aux1, aux2; // Auxiliar
<P>
  image= imread("imagem.png",CV_LOAD_IMAGE_GRAYSCALE);
<P>
  if(!image.data){
<BR>    cout << "Erro: Nao foi possivel carregar a imagem." << endl;
<BR>  }
<P>
  else{
<BR>  namedWindow("Janela",WINDOW_AUTOSIZE);
<P>
  width=image.size().width;
<BR>  height=image.size().height;
<P> 
// Translacao
<BR>  t = rand() % 3; // Troca aleatoria
<BR>  if(t==0){ // 1-2, 3-4
<BR>    for(int i=0;i<height/2;i++){
<BR>      for(int j=0;j<width/2;j++){
<BR>        aux1 = image.at<uchar>(i,j);
<BR>        image.at<uchar>(i,j) = image.at<uchar>(i,j + width/2);
<BR>        image.at<uchar>(i,j + width/2) = aux1;
<BR>        aux2 = image.at<uchar>(i + height/2,j);
<BR>        image.at<uchar>(i + height/2,j) = image.at<uchar>(i + height/2,j + width/2);
<BR>        image.at<uchar>(i + height/2,j + width/2) = aux2;
<BR>      }
<BR>    }
<BR>  }
<BR>  else if(t==1){ // 1-3, 2-4
<BR>    for(int i=0;i<height/2;i++){
<BR>      for(int j=0;j<width/2;j++){
<BR>        aux1 = image.at<uchar>(i,j);
<BR>        image.at<uchar>(i,j) = image.at<uchar>(i + height/2,j);
<BR>        image.at<uchar>(i + height/2,j) = aux1;
<BR>        aux2 = image.at<uchar>(i,j + width/2);
<BR>        image.at<uchar>(i,j + width/2) = image.at<uchar>(i + height/2,j + width/2);
<BR>        image.at<uchar>(i + height/2,j + width/2) = aux2;
<BR>      }
<BR>     }
<BR>  } 
<BR>  else{ // 1-4, 2-3
<BR>    for(int i=0;i<height/2;i++){
<BR>      for(int j=0;j<width/2;j++){
<BR>        aux1 = image.at<uchar>(i,j);
<BR>        image.at<uchar>(i,j) = image.at<uchar>(i + height/2,j + width/2);
<BR>        image.at<uchar>(i + height/2,j + width/2) = aux1;
<BR>        aux2 = image.at<uchar>(i,j + width/2);
<BR>        image.at<uchar>(i,j + width/2) = image.at<uchar>(i + height/2,j);
<BR>        image.at<uchar>(i + height/2,j) = aux2;
<BR>      }
<BR>     }
<BR>  }
<BR>// FimTranslacao
<P>  
  imshow("Janela", image);  
<BR>  imwrite("Exemplo2.png", image);
<BR>  waitKey();
<BR>  }
<P>
  return 0;
<BR>}

</I>
</font>

<H3> <center> Resultados </center> </H3>

Para obter resultados, o codigo correspondente, com o nome "trocaderegioes.cpp", foi executado pelo prompt de comando. Esse exerc&iacutecio foi executado diversas vezes, pois a troca de regi&otildees esta aleatoria e assim foi poss&iacutevel verificar todas as possibilidades, que est&atildeo mostradas a seguir: <P>
<center>
<BR>Troca 1-2, 3-4<P>
<IMG SRC = "Exemplo21.png" width=35% height = 35% alt="Exercicio 21"> 
<BR>Troca 1-3, 2-4<P>
<IMG SRC = "Exemplo22.png" width=35% height = 35% alt="Exercicio 22"> 
<BR>Troca 1-4, 2-3<P>
<IMG SRC = "Exemplo23.png" width=35% height = 35% alt="Exercicio 23"> 

<P>
<H2>Exerc&iacutecio 3 - Teoria sobre preenchimento de regi&otildees</H2>
</center>

<H3><center> Identifica&ccedil&atildeo do problema </center></H3>

Tendo-se como exemplo o codigo a seguir, que rotula uma imagem binaria utilizando o algoritmo <i>seedfill</i> para descobrir aglomerados de pixels, ao analisa-lo, consegue-se verificar alguns poss&iacuteveis problemas.<P>
O principal dele &eacute que o algoritmo de rotulacao n&atildeo consegue identificar mais de 255 objetos na imagem, porque ele trabalha com <i>grayscale</i>, que tem uma escala de tons de cinza que varia de 0 ate 255 e o algoritmo da diferentes rotulos.
Logo, se ha mais de 255 objetos na imagem, nao existir&atildeo cores diferentes para completar a contagem.<P>


<H3><center> Codigo comentado </center> </H3>
</center>
<font size = +1 face = "helvetica"> 
<I>
#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<P>
using namespace cv;
<P>
int main(int argc, char** argv){
<BR>  Mat image, mask;
<BR>  int width, height;
<BR>  int nobjects;
<P>  
  CvPoint p;
<BR>  image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);
<P>  
  if(!image.data){
<BR>    std::cout << "imagem nao carregou corretamente\n";
<BR>    return(-1);
<BR>  }
<BR>  width=image.size().width;
<BR>  height=image.size().height;
<P>
  p.x=0;
<BR>  p.y=0;
<P>
  // busca objetos com buracos presentes
<BR>  nobjects=0;
<BR>  for(int i=0; i<height; i++){
<BR>    for(int j=0; j<width; j++){
<BR>      if(image.at<uchar>(i,j) == 255){
<BR>		// achou um objeto
<BR>		nobjects++;
<BR>		p.x=j;
<BR>		p.y=i;
<BR>		floodFill(image,p,nobjects);
<BR>	  }
<BR>	}
<BR>  }
<BR>  imshow("image", image);
<BR>  imwrite("labeling.png", image);
<BR>  waitKey();
<BR>  return 0;
<BR>}
</I>
</font>

<H3> <center> Resolucao </center></H3> 

Uma solu&ccedil&atildeo simples para o problema em quest&atildeo desse codigo, seria criar uma nova variavel para realizar a mesma contagem que o <i>nobjects</i> e que possa ser resetada se o valor maximo for atingido. Isso tudo sem comprometer a rotula&ccedil&atildeo dos objetos desejados.

<center>

<H2>Exerc&iacutecio 4 - Identificando furos </H2>
</center>

Esse Exerc&iacutecio propoe a modifica&ccedil&atildeo de um algoritmo de rotula&ccedil&atildeo para separar regi&otildees desejadas e dentro delas selecionar um subconjunto. Dessa forma, deve-se praticar a logica e conceitos previos de rotula&ccedil&atildeo e de manipula&ccedil&atildeo de pixels. <P>
A ideia &eacute, dada uma imagem de cor binaria, com fundo preto e "bolhas" brancas espalhadas por ela, deve-se selecionar e contar as bolhas, separando-as entre as que possuem furo (em preto) e as que nao. <P>

<H3><center> Teoria </center></H3>

O codigo para a execu&ccedil&atildeo desse exerc&iacutecio consiste em tres passos principais. Inicialmente, deve-se retirar os elementos que tocam as bordas, ja que podem haver buracos nessas bolhas que nao sao visiveis na imagem dispon&iacutevel. Para tanto, igualam-se todos os pixeis da borda a 255 e depois pinta-se esses mesmos pixels e os que os tocam de 0.<P>
Em seguida, faz-se a rotula&ccedil&atildeo dos objetos atrav&eacutes do algoritmo <i>seedfill</i> ja visto. E, por fim, percorre-se cada objeto em busca de um pixel (ou mais) com a cor do fundo, realizando assim a contagem de elementos com e sem buracos.<P>
Esse codigo contou com dois extras explicitados nos comentarios, onde os buracos podem ou nao ficar visiveis na imagem final e pode-se destinguir as bolhas com apenas dois tons de cinza (um para com buracos e outro para sem) ou com a mesma varia&ccedil&atildeo de 0 a 255 do exerc&iacutecio anterior.<P>
Adicionalmente, o codigo gera uma nova imagem, com nome "labeling". <P>

<H3><center> Fun&ccedil&otildees </center></H3>

As fun&ccedil&otildees adicionais essenciais para a execu&ccedil&atildeo dessa atividade e o que elas representam s&atildeo: <P>

<UL>
<LI> CvPoint: gera um ponto bidimensional.
<LI> floodFill: executa o algoritmo <i>seedfill</i> na imagem com base em um pixel como semente.
</UL>

<H3><center>Imagem</center></H3>

A imagem utilizada como base para esse exerc&iacutecio esta mostrada a seguir:<P>

<center>
<IMG SRC = "imagem2.png" width=50% height=50% alt="Exemplo 4">

<H3> Codigo comentado </H3>
</center>
<font size = +1 face = "helvetica"> 
<I>
#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<P>
using namespace cv;
<P>
int main(int argc, char** argv){
<BR>  Mat image, mask;
<BR>  int width, height;
<BR>  int nobjects, cont;
<P>  
  CvPoint p;
<BR>  image = imread("imagem2.png",CV_LOAD_IMAGE_GRAYSCALE);
<P>  
  if(!image.data){
<BR>    std::cout << "Erro: Nao foi possivel carregar a imagem.\n";
<BR>    return(-1);
<BR>  }
<BR>  width=image.size().width;
<BR>  height=image.size().height;
<P>
  p.x=0;
<BR>  p.y=0;
<P>
  nobjects=0;
<BR>  cont = 0;
<BR>  for(int i=0; i<height; i++){
<BR>    for(int j=0; j<width; j++){
<BR>      if(image.at<uchar>(i,j) == 255){ // Encontrou um objeto
<BR>		nobjects++;
<BR>		cont++;
<BR>		p.x=j;
<BR>		p.y=i;
<BR>		floodFill(image,p,cont);
<BR>		if(cont==254){ cont = 0;} // Estourou o limite do contador, zerar
<BR>	  }
<BR>	}
<BR>  } 
<BR>  std::cout << "Numero de objetos: " << nobjects << "\n"; // Total de objetos encontrados
<P>
  imshow("image", image);
<BR>  imwrite("labeling.png", image);
<BR>  waitKey();
<BR>  return 0;
<BR>}
</I>
</font>

<H3><center> Resultados</center> </H3>

Como resultado, pode-se ver que o codigo conseguiu diferenciar as bolhas e tambem fazer a varia&ccedil&atildeo de tons, se desejado.<P>

<center>

Sem bolhas<P>
<IMG SRC = "Exercicio41.png" width=50% height=50% alt="Exercicio 41">
<BR>Com bolhas<P>
<IMG SRC = "Exercicio42.png" width=50% height=50% alt="Exercicio 42">
<BR>Com variacao de tons<P>
<IMG SRC = "Exercicio43.png" width=50% height=50% alt="Exercicio 43">


<H2>Exerc&iacutecio 5 - Equalizacao de Histograma</H2>
</center>

Esse exerc&iacutecio tem como objetivo explorar o conhecimento sobre histogramas de uma imagem e a manipula&ccedil&atildeo dele atraves do conjunto de bibliotecas OpenCV, alem de utilizar captura de video. Para isso, a ideia &eacute que, para cada imagem gerada, o programa .cpp equalize o histograma da imagem e mostre na tela.<P>

<H3><center> Teoria </center></H3>

Para o funcionamento desse codigo sao necessarios tres passos: capturar <i>frames</i> de video, realizar a equaliza&ccedil&atildeo do histograma para cada imagem dessas e exibir as images apos a modificacao.<P>
&Eacute importante saber que, para a manipulacao do histograma, foi necessario inicialmente mudar o sistema de cores de RGB para YCrCb. Em seguida, o histograma pode ser calculado e normalizado.<P>

<H3><center> Fun&ccedil&otildees </center></H3>

<UL>
<LI> VideoCapture: classe que permite uma variavel fluxo de video, possui como principais fun&ccedil&otildees <i>open</i> (abre video da camera) e <i>get</i> (receber informacoes da captura).
<LI> planes[]: separa a imagem em tons (planos) de vermelho, verde e azul.
<LI> cvtColor: consegue alterar o sistema de cores.
<LI> equalizeHist: equaliza diretamente um histograma.
<LI> merge: junta os planos de cor em uma imagem so.
<LI> calcHist: recebe referencia a ser processada, calcula o histograma e retorna para uma variavel definida.
<LI> normalize: normaliza os valores do histograma para o ficarem proporcionais ao maximo e m&iacutenimo encontrado.
<LI> line: gera grafico de barras.
</UL>

<H3><center>Imagem</center></H3>

Uma imagem para servir de previa foi mostrada, utilizando um algoritmo que exibe a imagem captada pela camera e gera o histograma.<P>

<center>

<IMG SRC = "Exemplo5.png" width=50% height=50% alt="Exemplo 5">

<H3> Codigo comentado </H3>
</center>
<font size = +1 face = "helvetica"> 
<I>
#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<P>
using namespace cv;
<BR>using namespace std;
<P>
int main(int argc, char** argv){
<BR>  Mat rawimage, eqimage;
<BR>  int width, height;
<BR>  VideoCapture cap;
<BR>  vector<Mat> planes;
<BR>  Mat histR, histG, histB;
<BR>  int nbins = 64;
<BR>  float range[] = {0, 256};
<BR>  const float *histrange = { range };
<BR>  bool uniform = true;
<BR>  bool acummulate = false;
<P>
  cap.open(0);
<P>  
  if(!cap.isOpened()){
<BR>    cout << "Erro: Cameras indisponiveis.";
<BR>    return -1;
<BR>  }
<P>  
  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
<BR>  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);
<P>
  cout << "Largura = " << width << endl;
<BR>  cout << "Altura  = " << height << endl;
<P>	
  int histw = nbins, histh = nbins/2;
<BR>  Mat histImgR(histh, histw, CV_8UC3, Scalar(0,0,0));
<BR>  Mat histImgG(histh, histw, CV_8UC3, Scalar(0,0,0));
<BR>  Mat histImgB(histh, histw, CV_8UC3, Scalar(0,0,0));
<P>
  while(1){
<BR>    cap >> rawimage;
<BR>    cvtColor(rawimage, eqimage, CV_BGR2YCrCb); // Muda a cor de RGB para YCrCb
<BR>    for (int i=0; i<1; i++) {
<BR>	    split (eqimage, planes);
<BR>	    equalizeHist(planes[i], planes[i]);
<BR>	    merge(planes, eqimage);
<BR>    }
<BR>    cvtColor(eqimage, eqimage, CV_YCrCb2BGR); 
<BR>    calcHist(&planes[0], 1, 0, Mat(), histR, 1,
<BR>             &nbins, &histrange,
<BR>             uniform, acummulate);
<BR>    calcHist(&planes[1], 1, 0, Mat(), histG, 1,
<BR>             &nbins, &histrange,
<BR>             uniform, acummulate);
<BR>    calcHist(&planes[2], 1, 0, Mat(), histB, 1,
<BR>             &nbins, &histrange,
<BR>             uniform, acummulate);
<P>

    normalize(histR, histR, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
<BR>    normalize(histG, histB, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
<BR>    normalize(histB, histB, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
<P>
    histImgR.setTo(Scalar(0));
<BR>    histImgG.setTo(Scalar(0));
<BR>    histImgB.setTo(Scalar(0));
<P>    
    for(int i=0; i<nbins; i++){
<BR>      line(histImgR, Point(i, histh),
<BR>           Point(i, cvRound(histR.at<float>(i))),
<BR>           Scalar(0, 0, 255), 1, 8, 0);
<BR>      line(histImgG, Point(i, histh),
<BR>           Point(i, cvRound(histG.at<float>(i))),
<BR>           Scalar(0, 255, 0), 1, 8, 0);
<BR>      line(histImgB, Point(i, histh),
<BR>           Point(i, cvRound(histB.at<float>(i))),
<BR>           Scalar(255, 0, 0), 1, 8, 0);
<BR>    }
<BR>    histImgR.copyTo(eqimage(Rect(0, 0       ,nbins, histh)));
<BR>    histImgG.copyTo(eqimage(Rect(0, histh   ,nbins, histh)));
<BR>    histImgB.copyTo(eqimage(Rect(0, 2*histh ,nbins, histh)));
<BR>    imshow("image", eqimage);
<BR>    if(waitKey(30) >= 0) break;
<BR>  }
<BR>  return 0;
<BR>}
</I>
</font>
<H3><center> Resultados</center> </H3>

Como proposto, pode-se ver n&atildeo apenas a diferenca na imagem, como o que mudou nos histogramas.<P>

<center>
<IMG SRC = "Exercicio5.png" width=50% height=50% alt="Exercicio 5">

<H2>Exerc&iacutecio 6 - </H2>
</center>

Esse exerc&iacutecio envolve a utilizacao de filtros e video. Para isso, sera criado um programa .cpp que recebera <i>frames</i> de video e, dependendo do que o usuario selecionar, aplicara um filtro espacial atraves do uso de mascaras. Nesse caso, estaremos tamb&eacutem testando o filtro laplaciano do gaussiano. <P>

<H3><center> Teoria </center></H3>

Para a execu&ccedil&atildeo dessa proposta, os passos ser&atildeo: a captura de imagens em fluxo, escolha do filtro, aplicacao da mascara e cria&ccedil&atildeo de um novo fluxo de imagens. O programa feito cria mascaras 3x3 para os seguintes filtros: do modulo, da media, gaussiano, vertical, horizontal e laplaciano. Os filtros s&atildeo ativados pelas teclas "a", "m", "g", "v", "h" e "l", respectivamente. Para ativar o laplaciano do gaussiano, foi necessario uma mascara 5x5 e o usuario deve teclar "x". <P>


<H3><center> Fun&ccedil&otildees </center></H3>

As principais fun&ccedil&otildees para a realiza&ccedil&atildeo desse exerc&iacutecio seguem:

<UL>
<LI> mask: recebe uma matriz em ponto flutuante com valores da mascara correspondente ao filtro desejado.
<LI> cvtColor: esta sendo usado para alterar o sistema de cores para tons de cinza.
<LI> frame.convertTo: converte as imagens capturadas pela camera para pontos flutuantes.
<LI> filter2D: realiza a convolu&ccedil&atildeo da mascara com a imagem capturada.

</UL>

<center>
<H3> Codigo comentado </H3>
</center>
<I>
<font size = +1 face = "helvetica"> 
#include <iostream>
<BR>#include <opencv2/opencv.hpp>
<BR>using namespace cv;
<BR>using namespace std;
<P>
void printmask(Mat &m){
<BR>  for(int i=0; i<m.size().height; i++){
<BR>    for(int j=0; j<m.size().width; j++){
<BR>      cout << m.at<float>(i,j) << ",";
<BR>    }
<BR>    cout << endl;
<BR>  }
<BR>}
<P>
void menu(){
<BR>  cout << "\nPressione a tecla para ativar o filtro: \n"
<BR>	  "a - Calcular o modulo\n"
<BR>          "m - Media\n"
<BR>          "g - Gauss\n"
<BR>          "v - Vertical\n"
<BR>	  "h - Horizontal\n"
<BR>          "l - Laplaciano\n"
<BR>          "x - Laplaciano do gaussiano\n"
<BR>	  "esc - Sair\n";
<BR>}
<P>
int main(int argvc, char** argv){
<BR>  VideoCapture video;
<BR>  float media[] = {1,1,1,
<BR>				   1,1,1,
<BR>				   1,1,1};
<BR>  float gauss[] = {1,2,1,
<BR>				   2,4,2,
<BR>				   1,2,1};
<BR>  float horizontal[]={-1,0,1,
<BR>					  -2,0,2,
<BR>					  -1,0,1};
<BR>  float vertical[]={-1,-2,-1,
<BR>					0,0,0,
<BR>					1,2,1};
<BR>  float laplacian[]={0,-1,0,
<BR>					 -1,4,-1,
<BR>					 0,-1,0};
<BR>  float lap_gauss[]={0,0,1,0,0,
<BR>		     0,1,2,1,0,
<BR>		     1,2,-16,2,1,
<BR>		     0,1,2,1,0,
<BR>		     0,0,1,0,0};
<P>
  Mat cap, frame, frame32f, frameFiltered;
<BR>  Mat mask(3,3,CV_32F), mask1;
<BR>  Mat result, result1;
<BR>  double width, height, min, max;
<BR>  int absolut;
<BR>  char key;
<P>  
  video.open(0); 
<BR>  if(!video.isOpened()) 
<BR>    return -1;
<BR>  width=video.get(CV_CAP_PROP_FRAME_WIDTH);
<BR>  height=video.get(CV_CAP_PROP_FRAME_HEIGHT);
<BR>  std::cout << "Largura =" << width << "\n";;
<BR>  std::cout << "Altura =" << height<< "\n";;
<P>
  namedWindow("filtroespacial",1);
<P>
  mask = Mat(3, 3, CV_32F, media); 
<BR>  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
<BR>  swap(mask, mask1);
<BR>  absolut=1; // calcs abs of the image
<P>
  menu();
<BR>  for(;;){
<BR>    video >> cap; 
<BR>    cvtColor(cap, frame, CV_BGR2GRAY);
<BR>    flip(frame, frame, 1);
<BR>    imshow("original", frame);
<BR>    frame.convertTo(frame32f, CV_32F);
<BR>    filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);
<BR>    if(absolut){
<BR>      frameFiltered=abs(frameFiltered);
<BR>    }
<BR>    frameFiltered.convertTo(result, CV_8U);
<BR>    imshow("filtroespacial", result);
<BR>    key = (char) waitKey(10);
<BR>    if( key == 27 ) break; // esc pressed!
<BR>    switch(key){
<BR>    case 'a':
<BR>	  menu();
<BR>      absolut=!absolut;
<BR>      break;
<BR>    case 'm':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, media);
<BR>      scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
<BR>      mask = mask1;
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'g':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, gauss);
<BR>      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
<BR>      mask = mask1;
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'h':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, horizontal);
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'v':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, vertical);
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'l':
<BR>	  menu();
<BR>      mask = Mat(3, 3, CV_32F, laplacian);
<BR>      printmask(mask);
<BR>      break;
<BR>    case 'x':
<BR>	  menu();
<BR>      mask = Mat(5, 5, CV_32F, lap_gauss);
<BR>      printmask(mask);
<BR>      break;
<BR>    default:
<BR>      break;
<BR>    }
<BR>  }
<BR>  return 0;
<BR>}
</font>
</I>
<H3><center> Resultados</center> </H3>

No fim, o programa mostra a imagem original e o filtro desejado. Para poder comparar o uso dos filtros, a seguir vem um exemplo do laplaciano do gaussiano e um com apenas o laplaciano: <P>

<center>
Laplaciano do gaussiano:<P>
<IMG SRC = "Exercicio6.png" width=80% height=80% alt="Exercicio 61">
<BR>Laplaciano:<P>
<IMG SRC = "Exercicio61.png" width=80% height=80% alt="Exercicio 62">

</font>
</body>

</html>
